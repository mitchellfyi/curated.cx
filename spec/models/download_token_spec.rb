# frozen_string_literal: true

# == Schema Information
#
# Table name: download_tokens
#
#  id                 :bigint           not null, primary key
#  download_count     :integer          default(0), not null
#  expires_at         :datetime         not null
#  last_downloaded_at :datetime
#  max_downloads      :integer          default(5), not null
#  token              :string           not null
#  created_at         :datetime         not null
#  updated_at         :datetime         not null
#  purchase_id        :bigint           not null
#
require "rails_helper"

RSpec.describe DownloadToken, type: :model do
  let(:tenant) { create(:tenant) }
  let(:site) { create(:site, tenant: tenant) }
  let(:digital_product) { create(:digital_product, :published, site: site) }
  let(:purchase) { create(:purchase, digital_product: digital_product) }

  describe "constants" do
    it "defines TOKEN_LENGTH" do
      expect(DownloadToken::TOKEN_LENGTH).to eq(32)
    end

    it "defines DEFAULT_EXPIRY_HOURS" do
      expect(DownloadToken::DEFAULT_EXPIRY_HOURS).to eq(1)
    end

    it "defines DEFAULT_MAX_DOWNLOADS" do
      expect(DownloadToken::DEFAULT_MAX_DOWNLOADS).to eq(5)
    end
  end

  describe "associations" do
    it { should belong_to(:purchase) }
    it { should have_one(:digital_product).through(:purchase) }
  end

  describe "validations" do
    subject { create(:download_token, purchase: purchase) }

    # Note: token and expires_at are auto-generated by callbacks, so we test
    # them with persisted records or direct validation tests
    it { should validate_presence_of(:download_count) }
    it { should validate_numericality_of(:download_count).only_integer.is_greater_than_or_equal_to(0) }
    it { should validate_presence_of(:max_downloads) }
    it { should validate_numericality_of(:max_downloads).only_integer.is_greater_than(0) }

    describe "token uniqueness" do
      it "validates uniqueness of token" do
        existing = create(:download_token, purchase: purchase)
        duplicate = build(:download_token, purchase: purchase)
        duplicate.token = existing.token

        expect(duplicate).not_to be_valid
        expect(duplicate.errors[:token]).to include("has already been taken")
      end
    end
  end

  describe "callbacks" do
    describe "generate_token!" do
      it "auto-generates token on create if blank" do
        token = create(:download_token, purchase: purchase)
        expect(token.token).to be_present
        expect(token.token.length).to be > 30
      end

      it "generates unique tokens" do
        token1 = create(:download_token, purchase: purchase)
        token2 = create(:download_token, purchase: purchase)

        expect(token1.token).not_to eq(token2.token)
      end
    end

    describe "set_default_expiry" do
      it "sets expires_at to 1 hour from now if blank" do
        freeze_time do
          token = create(:download_token, purchase: purchase, expires_at: nil)
          expect(token.expires_at).to be_within(1.second).of(1.hour.from_now)
        end
      end

      it "preserves explicit expires_at value" do
        explicit_time = 2.hours.from_now
        token = create(:download_token, purchase: purchase, expires_at: explicit_time)
        expect(token.expires_at).to be_within(1.second).of(explicit_time)
      end
    end
  end

  describe "scopes" do
    let!(:active_token) do
      create(:download_token, purchase: purchase, expires_at: 1.hour.from_now, download_count: 0)
    end
    let!(:expired_token) do
      create(:download_token, :expired, purchase: purchase)
    end
    let!(:exhausted_token) do
      create(:download_token, :exhausted, purchase: purchase, expires_at: 1.hour.from_now)
    end

    describe ".active" do
      it "returns tokens that are not expired and not exhausted" do
        expect(DownloadToken.active).to include(active_token)
        expect(DownloadToken.active).not_to include(expired_token)
        expect(DownloadToken.active).not_to include(exhausted_token)
      end
    end

    describe ".expired" do
      it "returns tokens that have expired" do
        expect(DownloadToken.expired).to include(expired_token)
        expect(DownloadToken.expired).not_to include(active_token)
      end
    end

    describe ".exhausted" do
      it "returns tokens that have reached max downloads" do
        expect(DownloadToken.exhausted).to include(exhausted_token)
        expect(DownloadToken.exhausted).not_to include(active_token)
      end
    end
  end

  describe "instance methods" do
    describe "#expired?" do
      it "returns true when expires_at is in the past" do
        token = build(:download_token, :expired, purchase: purchase)
        expect(token.expired?).to be true
      end

      it "returns false when expires_at is in the future" do
        token = build(:download_token, purchase: purchase, expires_at: 1.hour.from_now)
        expect(token.expired?).to be false
      end
    end

    describe "#exhausted?" do
      it "returns true when download_count >= max_downloads" do
        token = build(:download_token, :exhausted, purchase: purchase)
        expect(token.exhausted?).to be true
      end

      it "returns false when download_count < max_downloads" do
        token = build(:download_token, purchase: purchase, download_count: 3, max_downloads: 5)
        expect(token.exhausted?).to be false
      end
    end

    describe "#valid_for_download?" do
      it "returns true when not expired and not exhausted" do
        token = build(:download_token, purchase: purchase, expires_at: 1.hour.from_now, download_count: 0)
        expect(token.valid_for_download?).to be true
      end

      it "returns false when expired" do
        token = build(:download_token, :expired, purchase: purchase, download_count: 0)
        expect(token.valid_for_download?).to be false
      end

      it "returns false when exhausted" do
        token = build(:download_token, :exhausted, purchase: purchase, expires_at: 1.hour.from_now)
        expect(token.valid_for_download?).to be false
      end

      it "returns false when both expired and exhausted" do
        token = build(:download_token, purchase: purchase, expires_at: 1.hour.ago, download_count: 5, max_downloads: 5)
        expect(token.valid_for_download?).to be false
      end
    end

    describe "#downloads_remaining" do
      it "returns remaining downloads" do
        token = build(:download_token, purchase: purchase, download_count: 2, max_downloads: 5)
        expect(token.downloads_remaining).to eq(3)
      end

      it "returns 0 when exhausted" do
        token = build(:download_token, :exhausted, purchase: purchase)
        expect(token.downloads_remaining).to eq(0)
      end

      it "never returns negative" do
        token = build(:download_token, purchase: purchase, download_count: 10, max_downloads: 5)
        expect(token.downloads_remaining).to eq(0)
      end
    end

    describe "#record_download!" do
      it "increments download_count and sets last_downloaded_at" do
        freeze_time do
          token = create(:download_token, purchase: purchase, download_count: 0)

          expect(token.record_download!).to be true
          token.reload

          expect(token.download_count).to eq(1)
          expect(token.last_downloaded_at).to be_within(1.second).of(Time.current)
        end
      end

      it "returns false when token is expired" do
        token = create(:download_token, :expired, purchase: purchase)

        expect(token.record_download!).to be false
        expect(token.reload.download_count).to eq(0)
      end

      it "returns false when token is exhausted" do
        token = create(:download_token, :exhausted, purchase: purchase, expires_at: 1.hour.from_now)

        expect(token.record_download!).to be false
        # Should not increment beyond max
        expect(token.reload.download_count).to eq(5)
      end

      it "increments correctly up to max" do
        token = create(:download_token, :almost_exhausted, purchase: purchase, expires_at: 1.hour.from_now)

        expect(token.record_download!).to be true
        expect(token.reload.download_count).to eq(5)

        # Now exhausted, should fail
        expect(token.record_download!).to be false
        expect(token.reload.download_count).to eq(5)
      end
    end

    describe "#regenerate!" do
      it "generates a new token" do
        token = create(:download_token, purchase: purchase)
        old_token_value = token.token

        token.regenerate!

        expect(token.token).not_to eq(old_token_value)
      end

      it "resets expires_at to 1 hour from now" do
        freeze_time do
          token = create(:download_token, :expired, purchase: purchase)

          token.regenerate!

          expect(token.expires_at).to be_within(1.second).of(1.hour.from_now)
        end
      end

      it "resets download_count to 0" do
        token = create(:download_token, :exhausted, purchase: purchase, expires_at: 1.hour.from_now)

        token.regenerate!

        expect(token.download_count).to eq(0)
      end

      it "makes the token valid for download again" do
        token = create(:download_token, :expired, purchase: purchase)
        expect(token.valid_for_download?).to be false

        token.regenerate!

        expect(token.valid_for_download?).to be true
      end
    end
  end

  describe "token uniqueness guarantee" do
    it "handles token collision by regenerating" do
      # Create first token
      first_token = create(:download_token, purchase: purchase)

      # Mock SecureRandom to return the same value first, then a different one
      call_count = 0
      allow(SecureRandom).to receive(:urlsafe_base64).and_wrap_original do |method, *args|
        call_count += 1
        if call_count == 1
          first_token.token # Return existing token (collision)
        else
          method.call(*args) # Return a new random token
        end
      end

      # Create second token - should succeed with a different value
      second_token = create(:download_token, purchase: purchase)
      expect(second_token.token).not_to eq(first_token.token)
    end
  end
end
