#!/usr/bin/env ruby
# Anti-Pattern Detection Script - Prevents workarounds and shortcuts
# Ensures all implementations follow project goals and best practices

puts "üö´ Anti-Pattern Detection - No Shortcuts Allowed"
puts "=" * 60

def check_file(file_path)
  return unless File.exist?(file_path)
  content = File.read(file_path)
  violations = []

  # Ruby-specific anti-patterns
  if file_path.end_with?('.rb')
    violations.concat(check_ruby_antipatterns(content, file_path))
  end

  # ERB-specific anti-patterns
  if file_path.end_with?('.erb')
    violations.concat(check_erb_antipatterns(content, file_path))
  end

  # Test-specific anti-patterns
  if file_path.include?('spec/') || file_path.include?('test/')
    violations.concat(check_test_antipatterns(content, file_path))
  end

  violations
end

def check_ruby_antipatterns(content, file_path)
  violations = []

  # Skip spec files for app-level anti-patterns (they test the app, not part of it)
  is_spec_file = file_path.include?('spec/')

  # Detect quality tool bypasses (FORBIDDEN) - check in all files
  bypass_patterns = [
    /# rubocop:disable/i,
    /# rubocop:skip/i,
    /rubocop:todo/i,
    /safety_assured\s*do/i,
    /skip.*brakeman/i,
    /# TODO.*fix.*later/i,
    /# HACK/i,
    /# FIXME.*later/i,
    /\.silence_warnings/,
    /rescue\s*=>\s*nil\s*$/,  # Swallowing exceptions
    /rescue.*\n\s*#.*ignore/i
  ]

  bypass_patterns.each do |pattern|
    if content.match?(pattern)
      violations << {
        type: :forbidden_bypass,
        message: "Quality tool bypass detected: #{pattern.source}",
        severity: :critical,
        fix: "Remove bypass and fix the underlying issue properly"
      }
    end
  end

  # Skip remaining checks for spec files
  return violations if is_spec_file

  # Detect anti-patterns in models
  if file_path.include?('app/models/')
    # Missing acts_as_tenant workaround
    # Note: TenantScoped concern includes acts_as_tenant, so check for both
    if content.include?('tenant_id') && !content.include?('acts_as_tenant') && !content.include?('TenantScoped')
      unless content.match?(/class.*ApplicationRecord|abstract_class.*true|module\s/)
        violations << {
          type: :missing_tenant_scoping,
          message: "Model has tenant_id but uses manual scoping instead of acts_as_tenant",
          severity: :critical,
          fix: "Add 'acts_as_tenant :tenant' or include TenantScoped to properly scope the model"
        }
      end
    end

    # Business logic in models that should be in services
    if content.match?(/def.*send.*email|def.*process.*payment|def.*generate.*report/i)
      violations << {
        type: :business_logic_in_model,
        message: "Business logic detected in model - should be in service object",
        severity: :warning,
        fix: "Extract business logic to dedicated service class"
      }
    end
  end

  # Detect anti-patterns in controllers
  if file_path.include?('controllers/') && !file_path.include?('application_controller')
    # Direct database calls instead of using tenant scoping
    # Valid patterns: policy_scope, Current.tenant, Current.site, acts_as_tenant models
    db_calls = content.scan(/\.(where|find_by|create|update|destroy)\(/).count
    valid_scoping = content.include?('policy_scope') ||
                    content.include?('Current.tenant') ||
                    content.include?('Current.site') ||
                    content.include?('authorize') ||
                    content.match?(/Service\./)  # Uses a service layer

    if db_calls > 2 && !valid_scoping
      violations << {
        type: :unscoped_database_calls,
        message: "Direct database calls without tenant scoping",
        severity: :critical,
        fix: "Use policy_scope, Current.tenant, or service objects for database operations"
      }
    end

    # Business logic in controllers - only warn for very large controllers
    if content.lines.count > 100
      violations << {
        type: :fat_controller,
        message: "Controller is too large - extract logic to services",
        severity: :warning,
        fix: "Move business logic to service objects or concerns"
      }
    end
  end

  # Detect performance anti-patterns (only in app code, not config/spec/jobs)
  # Jobs may legitimately use sleep for rate limiting
  if file_path.start_with?('app/') && !file_path.include?('/jobs/')
    performance_issues = [
      /\.all\.each/,  # N+1 potential
      /\.find\(\d+\).*\.find\(\d+\)/,  # Multiple finds
      /User\.where.*\.where/  # Multiple wheres
    ]

    performance_issues.each do |pattern|
      if content.match?(pattern)
        violations << {
          type: :performance_antipattern,
          message: "Performance anti-pattern detected: #{pattern.source}",
          severity: :warning,
          fix: "Use proper eager loading, caching, or async processing"
        }
      end
    end

    # Check for debug statements - more specific patterns
    debug_patterns = [
      /^\s*puts\s/,          # puts at start of line
      /^\s*p\s+[@\w]/,       # p followed by variable
      /binding\.pry/,        # debugger
      /byebug/,              # debugger
      /debugger/             # debugger
    ]

    debug_patterns.each do |pattern|
      if content.match?(pattern)
        violations << {
          type: :debug_statement,
          message: "Debug statement detected: #{pattern.source}",
          severity: :warning,
          fix: "Remove debug statements before committing"
        }
      end
    end
  end

  violations
end

def check_erb_antipatterns(content, file_path)
  violations = []

  # Skip admin views - internal use doesn't require strict i18n
  return violations if file_path.include?('admin/')
  return violations if file_path.include?('active_storage/')
  return violations if file_path.include?('layouts/')

  # Check for obvious hardcoded user-facing content
  # Only check placeholder and title attributes which should be translated
  hardcoded_patterns = [
    /placeholder="[A-Za-z][A-Za-z\s]{5,}"/,  # Placeholder text
    /aria-label="[A-Za-z][A-Za-z\s]{5,}"/    # Aria labels
  ]

  hardcoded_patterns.each do |pattern|
    if content.match?(pattern)
      violations << {
        type: :hardcoded_strings,
        message: "Hardcoded placeholder/aria-label found - should use i18n keys",
        severity: :warning,
        fix: "Replace with <%= t('appropriate.key') %> and add translation"
      }
    end
  end

  # Missing accessibility attributes
  if content.include?('<img') && !content.match?(/alt=["'][^"']*["']/)
    violations << {
      type: :missing_accessibility,
      message: "Image without alt attribute",
      severity: :critical,
      fix: "Add proper alt text for accessibility compliance"
    }
  end

  violations
end

def check_test_antipatterns(content, file_path)
  violations = []

  # Only check actual spec files (not support files, factories, or helpers)
  return violations unless file_path.match?(/_spec\.rb$/)
  return violations if file_path.include?('spec/support/')

  # Test bypasses and skips - more specific patterns
  # Allow conditional skips like: skip "message" if condition
  test_bypasses = [
    /^\s*skip\s*$/,  # Bare skip without message
    /^\s*skip\s+["'][^"']+["']\s*$/,  # skip "message" on its own line (not conditional)
    /^\s*xit\s/,
    /^\s*xdescribe\s/,
    /^\s*xcontext\s/,
    /^\s*pending\s*$/  # Bare pending without message or block
  ]

  test_bypasses.each do |pattern|
    if content.match?(pattern)
      violations << {
        type: :test_bypass,
        message: "Unconditional test bypass detected: #{pattern.source}",
        severity: :critical,
        fix: "Fix the test properly instead of skipping it"
      }
    end
  end

  # Poor test practices
  if content.include?('sleep(')
    violations << {
      type: :flaky_test_pattern,
      message: "Sleep in test - indicates timing dependency",
      severity: :warning,
      fix: "Use proper waiting strategies or mocking"
    }
  end

  # Missing test coverage indicators - only for actual it blocks, not pending ones
  unless content.include?('expect') || content.include?('assert') || content.include?('should')
    # Count actual test blocks (not pending ones)
    active_test_count = content.scan(/^\s+it\s+['""]/).count - content.scan(/^\s+pending\b/).count
    if active_test_count > 0
      violations << {
        type: :empty_test,
        message: "Test without assertions detected",
        severity: :critical,
        fix: "Add proper expectations to validate behavior"
      }
    end
  end

  # Anti-pattern: Testing implementation instead of behavior
  if content.match?(/expect.*\.to receive.*and_return/)
    count = content.scan(/expect.*\.to receive/).length
    assertion_count = content.scan(/expect.*\.to eq|expect.*\.to be/).length

    if count > assertion_count
      violations << {
        type: :testing_implementation,
        message: "Over-mocking - test behavior, not implementation",
        severity: :warning,
        fix: "Focus on testing outcomes rather than internal method calls"
      }
    end
  end

  violations
end

# Main execution
if ARGV.empty?
  # Check all files
  files_to_check = Dir.glob("{app,spec,lib,config}/**/*.{rb,erb}")
else
  # Check specific files
  files_to_check = ARGV
end

all_violations = []
files_checked = 0

files_to_check.each do |file|
  next unless File.exist?(file)

  violations = check_file(file)
  if violations.any?
    all_violations << { file: file, violations: violations }
  end
  files_checked += 1
end

puts "üìä Checked #{files_checked} files"
puts ""

if all_violations.empty?
  puts "‚úÖ No anti-patterns detected - all implementations follow best practices"
  exit 0
else
  puts "üö´ ANTI-PATTERNS DETECTED - SHORTCUTS AND WORKAROUNDS FOUND"
  puts "=" * 60

  critical_count = 0
  warning_count = 0

  all_violations.each do |file_violations|
    puts "\nüìÅ #{file_violations[:file]}:"

    file_violations[:violations].each do |violation|
      case violation[:severity]
      when :critical
        puts "  ‚ùå CRITICAL: #{violation[:message]}"
        critical_count += 1
      when :warning
        puts "  ‚ö†Ô∏è  WARNING: #{violation[:message]}"
        warning_count += 1
      end
      puts "     üí° Fix: #{violation[:fix]}"
      puts ""
    end
  end

  puts "=" * 60
  puts "üìä Summary:"
  puts "  ‚ùå Critical issues: #{critical_count}"
  puts "  ‚ö†Ô∏è  Warnings: #{warning_count}"
  puts ""
  puts "üö´ ANTI-PATTERN ENFORCEMENT:"
  puts "  ‚Ä¢ No shortcuts or workarounds allowed"
  puts "  ‚Ä¢ Fix the root cause, not the symptom"
  puts "  ‚Ä¢ Follow project patterns and best practices"
  puts "  ‚Ä¢ Prioritize user experience and maintainability"
  puts "  ‚Ä¢ Use proper abstraction layers (services, decorators, etc.)"
  puts ""
  puts "üìö Reference:"
  puts "  ‚Ä¢ SOLID principles for proper architecture"
  puts "  ‚Ä¢ Rails conventions for consistency"
  puts "  ‚Ä¢ Multi-tenant patterns for data isolation"
  puts "  ‚Ä¢ i18n best practices for accessibility"
  puts "  ‚Ä¢ Proper test patterns for reliability"

  if critical_count > 0
    puts ""
    puts "üö´ BUILD BLOCKED - Fix critical anti-patterns before proceeding"
    exit 1
  else
    puts ""
    puts "‚ö†Ô∏è  Warnings found - address before committing for best practices"
    exit 0
  end
end
